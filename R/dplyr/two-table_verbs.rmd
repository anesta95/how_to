# [Two-table verbs](https://dplyr.tidyverse.org/articles/two-table.html)

It's rare that a data analysis only a single table of data. In practice, you'll normally have many tables that contribute to an analysis, and you need flexible tools to combine them. In dplyr, there are three families of verbs that work wtih two tables at a time:

* Mutating joins, which add new variables to one table from matching rows in another.

* Filtering joins, which filter observations from one table based on whether or not they match an observation in the other table.

* Set operations, which combine the observations in the data sets as if they were set elements.

(This discussion assumes that you have [tidy data](https://www.jstatsoft.org/v59/i10/), where the rows are observations and the columns are variables. If you’re not familiar with that framework, I’d recommend reading up on it first.)

All two-table verbs work similarly. The first two arguments are `x` and `y`, and provide the tables to combine. The output is always a new table with the same type as `x`.

## Mutating joins

Mutating joins allow you to combine variables from multiple tables. For example, consider the flights and airline data from the nycflights13 package. In one table we have flight information with an abbreviation for carrier, and in another we have a mapping between abbreviations and full names. You can use a join to add the carrier names to the flight data:

```{r}
library(dplyr)
library(nycflights13)

# Drop unimportant variables so it's easier to understand the join results.

flights2 <- flights %>% select(year:day, hour, origin, dest, tailnum, carrier)

flights2 %>%
    left_join(airlines)
```
### Controlling how the tables are matched

As well as `x` and `y`, each mutating join takes an arguement `by` that controls which variables are used to match observations in the two tables. There are a few ways to specify it, as I illustrate below with various tables from nycflights13:

* `NULL`, the default. dplyr will use all variables that appear in both tables, a **natural** join. For example, the flights and weather tables match on their common variables: year, month, day, hour and origin.

```{r}flights2 %>% left_join(weather)```
* A character vector, `by = "x"`. Like a natural join, but uses only some of the common variables. For example, `flights` and `planes` have `year` columns, but they mean different things so we only want to join by `tailnum`.

```{r}flights2 %>% left_join(planes, by = "tailnum")```

Note that the year columns in the output are disambiguated with a suffix. 

* A named character vector: `by = c("x" = "a")`. This will match variable `x` in table `x` to variable `a` in table `y`. The variables from use will be used in the output.

Each flight has an origin and destination `airport`, so we need to specify which one we want to join to:

```{r}
flights2 %>% left_join(airports, c("dest" = "faa"))

flights2 %>% left_join(airports, c("origin" = "faa"))
```

### Types of join

There are four types of mutating join, which differ in their behavior when a match is not found. We'll illustrate each with a simple example:

```{r}
df1 <- tibble(x = c(1, 2), y = 2:1)
df2 <- tibble(x = c(3, 1), a = 10, b = "a")
```

* `inner_join(x, y)` only includes observations that match in both `x` and `y`.

```{r} df1 %>% inner_join(df2) %>% knitr::kable()```

* `left_join(x, y)` includes all observations in `x`, regardless of weather they match or not. This is the most commonly used join because it ensures that you don't lose observations from your primary table.

```{r} df1 %>% left_join(df2)```

* `right_join(x, y)` includes all observations in `y`. It's equivalent to `left_join(y, x)`, but the columns and rows will be ordered differently.

```{r} 
df1 %>% right_join(df2)
df2 %>% left_join(df1)
```
* `full_join()` includes all observations from `x` and `y`.

```{r} df1 %>% full_join(df2)```

The left, right and full joins are collectively known as **outer joins**. When a row doesn't match in an outer join, the new variables are filled with missing values.

### Observations

While mutating joins are primarily used to add new variables, they can also generate new observations. If a match is not unique, a join will add all possible combinations (the Cartesian product) of the matching observations:

```{r}
df1 <- tibble(x = c(1, 1, 3), y = 1:3)
df2 <- tibble(x = c(1, 1, 2), z = c("a", "b", "a"))

df1 %>% left_join(df2)
```

## Filtering joins